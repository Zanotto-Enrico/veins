#ifndef RICERAYLEIGHFADING_H_
#define RICERAYLEIGHFADING_H_

#include <veins/base/phyLayer/AnalogueModel.h>
#include "veins/base/phyLayer/MappingBase.h"

/**
 * @brief Model to add Rician or Rayleigh fading.
 * This model generates small-scale fading, the samples follow a Rician or Rayleigh distribution, adjustable
 * by setting the desired K factor, see
 * R. J. Punnoose, P. V. Nikitin, and D. D. Stancil, "Efficient Simulation of Rician Fading within a Packet
 * Simulator," in 52nd IEEE Vehicular Technology Conference, Boston, MA, USA, September 2000
 *
 * They are generated by the sum-of-sinusoids method described in
 * Y. R. Zheng and Chengshan Xiao, "Improved Models for the Generation of Multiple Uncorrelated Rayleigh
 * Fading Waveforms,” IEEE Communications Letters, vol. 6, no. 6, pp. 256–258, June 2002.
 * They are thus time-correlated, depending on the relative speed of sender and receiver.
 *
 * A detailed explanation of this model in the context of 3D VANET simulation and example simulation results
 * can be found in:
 * Alexander Brummer, Thomas Deinlein and Anatoli Djanatliev, "On the Simulation of Vehicular Networking
 * Scenarios in Multi-Story Parking Garages," 13th IEEE Vehicular Networking Conference (VNC 2021),
 * Ulm, Germany (Virtual Event), November 2021
 *
 *
 * An example config.xml for this AnalogueModel can be the following:
 * @verbatim
     <AnalogueModel type="RiceRayleighFading">
         <!-- The signal frequency -->
         <parameter name="carrierFrequency" type="double" value="5.890e+9"/>
         <!-- How many paths should be considered for Rice/Rayleigh fading (recommended: 8) -->
         <parameter name="numPaths" type="long" value="8"/>
         <!-- Rician K factor in linear units (NOT dB), for Rayleigh fading use 0 -->
         <parameter name="kFactor" type="double" value="0"/>
         <!-- Interval at which Rice/Rayleigh fading samples are generated -->
         <parameter name="interval" type="double" value="0.0004"/>
     </AnalogueModel>
 @endverbatim
 *
 * @author Alexander Brummer
 *
 * @ingroup analogueModels
 */
class RiceRayleighFading : public AnalogueModel
{
public:
    /**
     * @brief Initializes the analogue model.
     *
     * @param carrierFrequency the carrier frequency
     * @param numPaths number of paths to be considered for Rice/Rayleigh fading
     * @param kFactor Rician K factor
     * @param interval interval at which fading samples are generated
     */
    RiceRayleighFading(double carrierFrequency, int numPaths, double kFactor, simtime_t_cref interval);

    /**
     * @brief Filters a specified AirFrame's Signal by adding the resulting attenuation.
     * @param frame the Airframe in question
     * @param senderPos the sender's position
     * @param receiverPos the receiver's position
     */
    virtual void filterSignal(AirFrame* frame, const Coord& senderPos, const Coord& receiverPos);

    /**
     * @brief Filters a specified AirFrame's Signal by adding the resulting attenuation. This version overwrites the K factor.
     * @param frame the Airframe in question
     * @param senderPos the sender's position
     * @param receiverPos the receiver's position
     */
    virtual void filterSignal(AirFrame* frame, const Coord& senderPos, const Coord& receiverPos, double kFactor);

protected:
    /**
     * @brief Get the relative speed of sender and receiver.
     * @param frame the Airframe in question
     * @return the relative speed
     */
    const double getRelSpeed(AirFrame* frame) const;

    /** @brief The carrier frequency. */
    double carrierFrequency;

    /** @brief Vector holding the angles of arrival for the different paths. */
    std::vector<double> aoa;

    /** @brief Random phases of the real part for each path. */
    std::vector<double> randPhaseReal;

    /** @brief Random phases of the imaginary part for each path. */
    std::vector<double> randPhaseImag;

    /** @brief The number of paths to be considered. */
    int numPaths;

    /** @brief The Rician K factor. */
    double kFactor;

    /** @brief The interval at which the fading samples are generated (= time resolution). */
    Argument interval;


    /** brief Mapping subclass returning the Rice/Rayleigh fading at the given time. */
    class Mapping : public SimpleConstMapping
    {
    public:
        Mapping(RiceRayleighFading& model, double relSpeed, double kFactor, const Argument& start,
                const Argument& interval, const Argument& end) :
                SimpleConstMapping(Dimension::time(), start, end, interval), model(model), relSpeed(relSpeed), kFactor(
                        kFactor)
        {
        }

        virtual double getValue(const Argument& pos) const;

        ConstMapping* constClone() const
        {
            return new Mapping(*this);
        }
    protected:
        RiceRayleighFading& model;

        double relSpeed;

        double kFactor;
    };

};

#endif /* RICERAYLEIGHFADING_H_ */
